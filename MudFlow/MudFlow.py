__author__ = 'Vince'
#!/usr/bin/python
# -*- coding: utf-8 -*-


import sys
reload(sys)
sys.setdefaultencoding('utf-8')

import shutil
from GlobalData import *
import multiprocessing as mp
from MudFlowUtils import *
from Classification import Classification



logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger('sys.stdout')


def rmAd(caller):
    '''
    Remove sources from Ad frameworks.

    :param String caller: Caller's class and method
    :return Whether the source is from an Ad framework
    :rtype Boolean
    '''

    for word in Ad_Frameworks:
        if word in caller:
            return True
        else:
            continue
    return False


def getCompletion(flowlog):
    '''
    Get completion of a FlowDroid log file.
    Only dealing with completed output.

    :param Linelist flowlog: Contents of a FlowDroid log file
    :return Whether the FlowDroid output is completed
    :rtype Boolean
    '''

    if len(flowlog) > 1 and flowlog[-1].startswith('Analysis has run'):
        return True
    else:
        return False


def getFlow(AppName, output):
    '''
    Get flow features of Susi Categories, Classes and Methods.
    Using FlowDroid to generate features.

    :param String AppName: Absolute path of an Android application
    :param String output: Output directory
    :return FlowSusiSrc2Snk: Flow features of an Android application, Susi category level
    :rtype List([String])
    :return FlowClassSrc2Snk: Flow features of an Android application, API class level
    :rtype List([String])
    :return FlowMethodSrc2Snk: Flow features of an Android application, API method level
    :rtype List([String])
    '''

    FlowSusiSrc2Snk = []
    FlowClassSrc2Snk = []
    FlowMethodSrc2Snk = []

    if not os.path.exists('Metadata'+os.path.sep+output+os.path.sep+os.path.basename(AppName)[:-4]+'FlowDroidLog.txt'):
        FlowDroidCommand = 'timeout '+timeout+' java -Xmx'+ram+' -cp soot-trunk.jar:soot-infoflow.jar:soot-infoflow-android.jar:slf4j-api-1.7.5.jar:slf4j-simple-1.7.5.jar:axml-2.0.jar soot.jimple.infoflow.android.TestApps.Test '
        os.system(FlowDroidCommand+AppName+' '+platform+' --nostatic --aplength 3 --aliasflowins --nopaths --noarraysize --layoutmode none -> '+'Metadata'+os.path.sep+output+os.path.sep+os.path.basename(AppName)[:-4]+'FlowDroidLog.txt')
    with open('Metadata'+os.path.sep+output+os.path.sep+os.path.basename(AppName)[:-4]+'FlowDroidLog.txt', 'r') as f:
        logger.info('Extracting Flow features from '+os.path.basename(AppName))
        lines = f.readlines()
        if getCompletion(lines):  # Only dealing with completed output
            for linenum, line in enumerate(lines):
                if line.startswith('Found a flow to sink '):
                    line = line.replace('Found a flow to sink ', '')
                    if line.startswith('$'):
                        snkclass = line.split(' ')[3].replace(':', '').split('<')[-1]
                        if '<init>' in line.split(' ')[5]:
                            snkmethod = snkclass.split('.')[-1]+'.'+'>'.join(line.split(' ')[5].split('>')[:-1])
                        else: snkmethod = snkclass.split('.')[-1]+'.'+line.split(' ')[5].split('>')[0]
                        snkname = line.split(' ')[5].split('(')[0]
                        snk = snkclass+' '+snkname
                    else:
                        snkclass = line.split(' ')[1].replace(':', '').split('<')[-1]
                        if '<init>' in line.split(' ')[3]:
                            snkmethod = snkclass.split('.')[-1]+'.'+'>'.join(line.split(' ')[3].split('>')[:-1])
                        else: snkmethod = snkclass.split('.')[-1]+'.'+line.split(' ')[3].split('>')[0]
                        snkname = line.split(' ')[3].split('(')[0]
                        snk = snkclass+' '+snkname
                    if not ') ' in SusiApiSinkMap.get(snk, '(UNKNOWN)'):
                        snkcat = 'SNK'+ SusiApiSinkMap.get(snk, '(UNKNOWN)')
                        for l in lines[linenum+1:]:
                            if l.startswith('	-') and ('parameter' not in l.split('<')[0]):
                                if 'specialinvoke' in l.split('<')[0]:
                                    if '=' in l.split('<')[0]:
                                        if not rmAd(l.split(' ')[7]):
                                            srcclass = l.split(' ')[4].replace(':', '').split('<')[-1]
                                            if '<init>' in l.split(' ')[6]:
                                                srcmethod = srcclass.split('.')[-1]+'.'+'>'.join(l.split(' ')[6].split('>')[:-1])
                                            else: srcmethod = srcclass.split('.')[-1]+'.'+l.split(' ')[6].split('>')[0]
                                            srcname = l.split(' ')[6].split('(')[0]
                                            src = srcclass+' '+srcname
                                    elif l.startswith('	- specialinvoke '):
                                        if not rmAd(l.split(' ')[5]):
                                            srcclass = l.split(' ')[2].replace(':', '').split('<')[-1]
                                            if '<init>' in l.split(' ')[4]:
                                                srcmethod = srcclass.split('.')[-1]+'.'+'>'.join(l.split(' ')[4].split('>')[:-1])
                                            else: srcmethod = srcclass.split('.')[-1]+'.'+l.split(' ')[4].split('>')[0]
                                            srcname = l.split(' ')[4].split('(')[0]
                                            src = srcclass+' '+srcname
                                    # else: return ['ERROR'], ['ERROR'], ['ERROR']
                                elif 'virtualinvoke' in l.split('<')[0]:
                                    if '=' in l.split('<')[0]:
                                        if not rmAd(l.split(' ')[7]):
                                            srcclass = l.split(' ')[4].replace(':', '').split('<')[-1]
                                            if '<init>' in l.split(' ')[6]:
                                                srcmethod = srcclass.split('.')[-1]+'.'+'>'.join(l.split(' ')[6].split('>')[:-1])
                                            else: srcmethod = srcclass.split('.')[-1]+'.'+l.split(' ')[6].split('>')[0]
                                            srcname = l.split(' ')[6].split('(')[0]
                                            src = srcclass+' '+srcname
                                    elif l.startswith('	- virtualinvoke '):
                                        if not rmAd(l.split(' ')[5]):
                                            srcclass = l.split(' ')[2].replace(':', '').split('<')[-1]
                                            if '<init>' in l.split(' ')[4]:
                                                srcmethod = srcclass.split('.')[-1]+'.'+'>'.join(l.split(' ')[4].split('>')[:-1])
                                            else: srcmethod = srcclass.split('.')[-1]+'.'+l.split(' ')[4].split('>')[0]
                                            srcname = l.split(' ')[4].split('(')[0]
                                            src = srcclass+' '+srcname
                                    # else : return ['ERROR'], ['ERROR'], ['ERROR']
                                elif 'interfaceinvoke' or 'staticinvoke' in l.split('<')[0]:
                                    if '=' in l.split('<')[0]:
                                        if not rmAd(l.split(' ')[7]):
                                            srcclass = l.split(' ')[4].replace(':', '').split('<')[-1]
                                            if '<init>' in l.split(' ')[6]:
                                                srcmethod = srcclass.split('.')[-1]+'.'+'>'.join(l.split(' ')[6].split('>')[:-1])
                                            else: srcmethod = srcclass.split('.')[-1]+'.'+l.split(' ')[6].split('>')[0]
                                            srcname = l.split(' ')[6].split('(')[0]
                                            src = srcclass+' '+srcname
                                    elif l.startswith('	- interfaceinvoke '):
                                        if not rmAd(l.split(' ')[5]):
                                            srcclass = l.split(' ')[2].replace(':', '').split('<')[-1]
                                            if '<init>' in l.split(' ')[4]:
                                                srcmethod = srcclass.split('.')[-1]+'.'+'>'.join(l.split(' ')[4].split('>')[:-1])
                                            else: srcmethod = srcclass.split('.')[-1]+'.'+l.split(' ')[4].split('>')[0]
                                            srcname = l.split(' ')[4].split('(')[0]
                                            src = srcclass+' '+srcname
                                # else: return ['ERROR'], ['ERROR'], ['ERROR']
                                srccat = 'SRC' + SusiApiSrcMap.get(src, '(UNKNOWN)')
                                if not ((snkcat == 'SNK(UNKNOWN)') and (srccat == 'SRC(UNKNOWN)')):
                                    FlowSusiSrc2Snk.append('CAT-<'+srccat+' -> '+snkcat+'>')
                                    FlowClassSrc2Snk.append('CLASS-<'+srcclass+' -> '+snkclass+'>')
                                    FlowMethodSrc2Snk.append('METHOD-<'+src.replace(' ', '.')+'() -> '+snk.replace(' ', '.')+'()>')
                            elif l.startswith('Found a flow to sink'):
                                break
                    elif ') ' in SusiApiSinkMap.get(snk):
                        logger.info('-'*10+'One API belongs to 2 Categories'+'-'*10)
                        snkcat1 = 'SNK' + SusiApiSinkMap.get(snk).split(' ')[0]
                        snkcat2 = 'SNK' + SusiApiSinkMap.get(snk).split(' ')[1]
                        for l in lines[linenum+1:]:
                            if l.startswith('	-') and ('parameter' not in l.split('<')[0]):
                                if 'specialinvoke' in l.split('<')[0]:
                                    if '=' in l.split('<')[0]:
                                        if not rmAd(l.split(' ')[7]):
                                            srcclass = l.split(' ')[4].replace(':', '').split('<')[-1]
                                            if '<init>' in l.split(' ')[6]:
                                                srcmethod = srcclass.split('.')[-1]+'.'+'>'.join(l.split(' ')[6].split('>')[:-1])
                                            else: srcmethod = srcclass.split('.')[-1]+'.'+l.split(' ')[6].split('>')[0]
                                            srcname = l.split(' ')[6].split('(')[0]
                                            src = srcclass+' '+srcname
                                    elif l.startswith('- specialinvoke '):
                                        if not rmAd(l.split(' ')[5]):
                                            srcclass = l.split(' ')[2].replace(':', '').split('<')[-1]
                                            if '<init>' in l.split(' ')[4]:
                                                srcmethod = srcclass.split('.')[-1]+'.'+'>'.join(l.split(' ')[4].split('>')[:-1])
                                            else: srcmethod = srcclass.split('.')[-1]+'.'+l.split(' ')[4].split('>')[0]
                                            srcname = l.split(' ')[4].split('(')[0]
                                            src = srcclass+' '+srcname
                                elif 'virtualinvoke' in l.split('<')[0]:
                                    if '=' in l.split('<')[0]:
                                        if not rmAd(l.split(' ')[7]):
                                            srcclass = l.split(' ')[4].replace(':', '').split('<')[-1]
                                            if '<init>' in l.split(' ')[6]:
                                                srcmethod = srcclass.split('.')[-1]+'.'+'>'.join(l.split(' ')[6].split('>')[:-1])
                                            else: srcmethod = srcclass.split('.')[-1]+'.'+l.split(' ')[6].split('>')[0]
                                            srcname = l.split(' ')[6].split('(')[0]
                                            src = srcclass+' '+srcname
                                    elif l.startswith('	- virtualinvoke '):
                                        if not rmAd(l.split(' ')[5]):
                                            srcclass = l.split(' ')[2].replace(':', '').split('<')[-1]
                                            if '<init>' in l.split(' ')[4]:
                                                srcmethod = srcclass.split('.')[-1]+'.'+'>'.join(l.split(' ')[4].split('>')[:-1])
                                            else: srcmethod = srcclass.split('.')[-1]+'.'+l.split(' ')[4].split('>')[0]
                                            srcname = l.split(' ')[4].split('(')[0]
                                            src = srcclass+' '+srcname
                                    # else: return ['ERROR'], ['ERROR'], ['ERROR']
                                elif 'interfaceinvoke' or 'staticinvoke' in l.split('<')[0]:
                                    if '=' in l.split('<')[0]:
                                        if not rmAd(l.split(' ')[7]):
                                            srcclass = l.split(' ')[4].replace(':', '').split('<')[-1]
                                            if '<init>' in l.split(' ')[6]:
                                                srcmethod = srcclass.split('.')[-1]+'.'+'>'.join(l.split(' ')[6].split('>')[:-1])
                                            else: srcmethod = srcclass.split('.')[-1]+'.'+l.split(' ')[6].split('>')[0]
                                            srcname = l.split(' ')[6].split('(')[0]
                                            src = srcclass+' '+srcname
                                    elif l.startswith('	- interfaceinvoke '):
                                        if not rmAd(l.split(' ')[5]):
                                            srcclass = l.split(' ')[2].replace(':', '').split('<')[-1]
                                            if '<init>' in l.split(' ')[4]:
                                                srcmethod = srcclass.split('.')[-1]+'.'+'>'.join(l.split(' ')[4].split('>')[:-1])
                                            else: srcmethod = srcclass.split('.')[-1]+'.'+l.split(' ')[4].split('>')[0]
                                            srcname = l.split(' ')[4].split('(')[0]
                                            src = srcclass+' '+srcname
                                # else: return ['ERROR'], ['ERROR'], ['ERROR']
                                srccat = 'SRC' + SusiApiSrcMap.get(src, '(UNKNOWN)')
                                if not ((snkcat1 == 'SNK(UNKNOWN)') and (srccat == 'SRC(UNKNOWN)')):
                                    FlowSusiSrc2Snk.append('CAT-<'+srccat+' -> '+snkcat1+'>')
                                    FlowClassSrc2Snk.append('CLASS-<'+srcclass+' -> '+snkclass+'>')
                                    FlowMethodSrc2Snk.append('METHOD-<'+src.replace(' ', '.')+'() -> '+snk.replace(' ', '.')+'()>')
                                if not ((snkcat2 == 'SNK(UNKNOWN)') and (srccat == 'SRC(UNKNOWN)')):
                                    FlowSusiSrc2Snk.append('CAT-<'+srccat+' -> '+snkcat2+'>')
                            elif l.startswith('Found a flow'):
                                break
            return FlowSusiSrc2Snk, FlowClassSrc2Snk, FlowMethodSrc2Snk
        else:
            logger.debug('Flow of '+os.path.basename(AppName)+', incomplete')
            return ['incomplete'], ['incomplete'], ['incomplete']


def ExtractFlowFeatures(app, outputpath, combination):
    '''
    Generating Flow features of Cat, Class, Method levels from an Android application.
    Dumping features into files.

    :param String app: Absolute path of an Android application
    :param String outputpath: Output dir, default is 'Malware'/'Benign'
    :param String combination: Feature combination option of flow features of CAT, Class and Method levels,
                               3 chars of '0'/'1'(ex/include)
    '''

    CatFrqDict = {}
    ClassFrqDict = {}
    MethodFrqDict = {}
    DecompilationDir = os.path.basename(app)[:-4]
    [FlowSusiCat, FlowClass, FlowMethod] = getFlow(app, outputpath)
    if not (FlowClass == ['incomplete'] or FlowMethod == ['incomplete'] or FlowSusiCat == ['incomplete']):
        for word in FlowSusiCat:
            if CatFrqDict.has_key(word): CatFrqDict[word] += 1
            else: CatFrqDict[word] = 1
        if not os.path.exists('Metadata'+os.path.sep+outputpath+os.path.sep+DecompilationDir+'CatFeature.json'):
            with open('Metadata'+os.path.sep+outputpath+os.path.sep+DecompilationDir+'CatFeature.json', 'w') as f_write2:
                for word in FlowSusiCat:
                    print >> f_write2, word

        for word in FlowClass:
            if ClassFrqDict.has_key(word): ClassFrqDict[word] += 1
            else: ClassFrqDict[word] = 1
        if not os.path.exists('Metadata'+os.path.sep+outputpath+os.path.sep+DecompilationDir+'ClassFeature.json'):
            with open('Metadata'+os.path.sep+outputpath+os.path.sep+DecompilationDir+'ClassFeature.json', 'w') as f_write1:
                for word in FlowClass:
                    print >> f_write1, word

        for word in FlowMethod:
            if MethodFrqDict.has_key(word): MethodFrqDict[word] += 1
            else: MethodFrqDict[word] = 1
        if not os.path.exists('Metadata'+os.path.sep+outputpath+os.path.sep+DecompilationDir+'MethodFeature.json'):
            with open('Metadata'+os.path.sep+outputpath+os.path.sep+DecompilationDir+'MethodFeature.json', 'w') as f_write0:
                for word in FlowMethod:
                    print >> f_write0, word

        with open('Data'+os.path.sep+outputpath+os.path.sep+DecompilationDir+'.Features', 'w') as f:
            if combination[0] == '1':
                for key in CatFrqDict:
                    for i in range(int(CatFrqDict.get(key))):
                        print >> f, key

            if combination[1] == '1':
                for key in ClassFrqDict:
                    for i in range(int(ClassFrqDict.get(key))):
                        print >> f, key

            if combination[2] == '1':
                for key in MethodFrqDict:
                    for i in range(int(MethodFrqDict.get(key))):
                        print >> f, key


def main(MalDir, BenDir, FeatureCombination='111'):
    '''

    :param String MalDir:
    :param String BenDir:
    :param String FeatureCombination:
    '''

    # 1 - Initializing
    createdir('Metadata'+os.path.sep+'Malware')
    createdir('Metadata'+os.path.sep+'Benign')
    createdir('Data'+os.path.sep+'Malware')
    createdir('Data'+os.path.sep+'Benign')

    # 2 - Extracting flow features from apps
    pool = mp.Pool(NumFlowProcesses)
    for file in walk(MalDir, '.apk'):
        pool.apply_async(ExtractFlowFeatures, args=(file, 'Malware', FeatureCombination))
    for file in walk(BenDir, '.apk'):
        pool.apply_async(ExtractFlowFeatures, args=(file, 'Benign', FeatureCombination))
    pool.close()
    pool.join()

    # 3 - Classifying
    Classification('Data'+os.path.sep+'Malware', 'Data'+os.path.sep+'Benign', 0.3)

    # 4. Remove feature files after classification
    for file in walk('Data', '.Features'):
        os.system('rm -rf '+file)

if __name__ == '__main__':

    main(MalDir=sys.argv[1],  # absolute path of Mal
         BenDir=sys.argv[2],  # absolute path of Ben
         FeatureCombination=sys.argv[3])  # feature combination option, default is '111'
