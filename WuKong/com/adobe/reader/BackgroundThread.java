package com.adobe.reader;

import android.os.Handler;
import android.os.Looper;
import android.os.Message;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;

public class BackgroundThread
  extends Thread
{
  private static final int SOME_MESSAGE_TYPE = 1;
  private static final String THREAD_NAME = "BackgroundThread";
  private final ConcurrentHashMap<Integer, AtomicInteger[]> mCancelRunnables;
  private Handler mHandler;
  private boolean mIsBackgroundThreadWaiting = false;
  private boolean mIsUIThreadWaiting = false;
  private int mRunnableCount;
  private final Object mRunnableSyncObject = new Object();
  private final Object mSyncObject = new Object();
  
  public BackgroundThread(int paramInt)
  {
    this.mRunnableCount = paramInt;
    this.mCancelRunnables = new ConcurrentHashMap();
  }
  
  private AtomicInteger getCancelStatus(int paramInt1, int paramInt2)
  {
    AtomicInteger[] arrayOfAtomicInteger = (AtomicInteger[])this.mCancelRunnables.get(Integer.valueOf(paramInt1));
    if (arrayOfAtomicInteger != null) {
      return arrayOfAtomicInteger[paramInt2];
    }
    arrayOfAtomicInteger = new AtomicInteger[this.mRunnableCount];
    int i = 0;
    for (;;)
    {
      if (i >= this.mRunnableCount)
      {
        this.mCancelRunnables.putIfAbsent(Integer.valueOf(paramInt1), arrayOfAtomicInteger);
        return ((AtomicInteger[])this.mCancelRunnables.get(Integer.valueOf(paramInt1)))[paramInt2];
      }
      arrayOfAtomicInteger[i] = new AtomicInteger();
      i += 1;
    }
  }
  
  private void waitCallingThread()
  {
    synchronized (this.mRunnableSyncObject)
    {
      for (;;)
      {
        if (!this.mIsUIThreadWaiting) {
          return;
        }
        try
        {
          this.mRunnableSyncObject.wait();
        }
        catch (InterruptedException localInterruptedException) {}
      }
    }
  }
  
  public void cancel(int paramInt1, int paramInt2)
  {
    if ((paramInt2 < 0) || (paramInt2 >= this.mRunnableCount)) {
      return;
    }
    getCancelStatus(paramInt1, paramInt2).incrementAndGet();
  }
  
  public void messageCancelled(int paramInt1, int paramInt2)
  {
    if ((paramInt2 < 0) || (paramInt2 >= this.mRunnableCount)) {
      return;
    }
    getCancelStatus(paramInt1, paramInt2).decrementAndGet();
  }
  
  public void notifyThread()
  {
    synchronized (this.mSyncObject)
    {
      this.mIsBackgroundThreadWaiting = false;
      this.mSyncObject.notifyAll();
      return;
    }
  }
  
  public void postToBackgroundThread(long paramLong, boolean paramBoolean)
  {
    if (this.mHandler == null) {}
    do
    {
      return;
      Message localMessage = this.mHandler.obtainMessage();
      localMessage.what = 1;
      localMessage.obj = new ARBackgroundRunnableAndroid(paramLong, Thread.currentThread(), paramBoolean, this);
      if (paramBoolean) {
        this.mIsUIThreadWaiting = true;
      }
      this.mHandler.sendMessage(localMessage);
    } while (!paramBoolean);
    waitCallingThread();
  }
  
  public void run()
  {
    setName("BackgroundThread");
    Looper.prepare();
    this.mHandler = new Handler()
    {
      public void handleMessage(Message paramAnonymousMessage)
      {
        switch (paramAnonymousMessage.what)
        {
        default: 
          return;
        }
        ((ARRunnableAndroid)paramAnonymousMessage.obj).run();
      }
    };
    Looper.loop();
  }
  
  public void setLowPriority()
  {
    setPriority(1);
  }
  
  public void setNormalPriority()
  {
    setPriority(5);
  }
  
  public boolean shouldCancelMessage(int paramInt1, int paramInt2)
  {
    return (paramInt2 >= 0) && (paramInt2 < this.mRunnableCount) && (getCancelStatus(paramInt1, paramInt2).get() > 0);
  }
  
  public void stopThread()
  {
    if (!isAlive()) {}
    while (this.mHandler == null) {
      return;
    }
    this.mHandler.removeMessages(1);
    this.mHandler.getLooper().quit();
  }
  
  public void waitThread()
  {
    if (Thread.currentThread().getId() != getId()) {
      return;
    }
    for (;;)
    {
      synchronized (this.mSyncObject)
      {
        this.mIsBackgroundThreadWaiting = true;
        if (!this.mIsBackgroundThreadWaiting) {
          return;
        }
      }
      try
      {
        this.mSyncObject.wait();
      }
      catch (InterruptedException localInterruptedException) {}
    }
  }
  
  public void wakeupCallingThread(Thread arg1)
  {
    synchronized (this.mRunnableSyncObject)
    {
      this.mIsUIThreadWaiting = false;
      this.mRunnableSyncObject.notify();
      return;
    }
  }
}
