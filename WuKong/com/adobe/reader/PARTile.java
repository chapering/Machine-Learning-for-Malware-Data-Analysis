package com.adobe.reader;

import android.graphics.Bitmap;
import android.graphics.Bitmap.Config;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.ReentrantLock;

class PARTile
{
  public static final double FACTOR_TILE_SIZE_APPROX = 2.0D;
  public static final int kComplete = 5;
  public static final int kDirty = 4;
  public static final int kEmpty = 2;
  public static final int kInvalid = 6;
  public static final int kNotRequired = 3;
  public static final int kPartial = 3;
  public static final int kRequired = 2;
  public static final int kUninitialized = 1;
  public static final int kUnknown = 1;
  public Bitmap mBitmap;
  private int mHeight;
  private boolean mIsThumbnail = false;
  private final ReentrantLock mLock = new ReentrantLock();
  private int mOverlayRequirement;
  private final AtomicInteger mRefCount = new AtomicInteger(0);
  private AtomicInteger mState = new AtomicInteger(1);
  private int mWidth;
  
  public PARTile(int paramInt1, int paramInt2, PARTileKey paramPARTileKey)
  {
    this.mWidth = paramInt1;
    this.mHeight = paramInt2;
    this.mOverlayRequirement = 1;
    ARBitmapPool localARBitmapPool = ARApp.getARApp().getBitmapPool();
    if (paramPARTileKey.mTileType == 1)
    {
      this.mIsThumbnail = true;
      if (paramPARTileKey.mMemoryInfo != 1) {}
    }
    try
    {
      this.mBitmap = Bitmap.createBitmap(this.mWidth, this.mHeight, Bitmap.Config.RGB_565);
      if (this.mBitmap != null) {
        fill(0, 0, paramInt1, paramInt2, 16777215);
      }
      for (;;)
      {
        if ((this.mBitmap != null) || (paramPARTileKey.mMemoryInfo != 1)) {
          this.mState.set(2);
        }
        return;
        if (paramPARTileKey.mMemoryInfo == 1) {
          this.mBitmap = localARBitmapPool.obtainBitmap(this.mWidth, this.mHeight);
        }
      }
    }
    catch (OutOfMemoryError localOutOfMemoryError)
    {
      for (;;) {}
    }
    catch (IllegalArgumentException localIllegalArgumentException)
    {
      for (;;) {}
    }
  }
  
  public static double calculateTileSize(int paramInt1, int paramInt2)
  {
    return paramInt1 * paramInt2 * 2.0D / 1024.0D;
  }
  
  public void addRef()
  {
    this.mRefCount.incrementAndGet();
  }
  
  public void copyPixels(PARTile paramPARTile)
  {
    setPixels(paramPARTile.getPixels());
  }
  
  public void fill(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5)
  {
    if (this.mBitmap != null) {
      this.mBitmap.eraseColor(0xFF000000 | paramInt5);
    }
  }
  
  public Bitmap getBitmap()
  {
    return this.mBitmap;
  }
  
  public int getHeight()
  {
    return this.mHeight;
  }
  
  public int getOverlayRequirement()
  {
    return this.mOverlayRequirement;
  }
  
  public int[] getPixels()
  {
    int[] arrayOfInt2 = ARApp.getARApp().getBitmapPool().getPixelBuffer(this.mWidth, this.mHeight);
    int[] arrayOfInt1;
    if (arrayOfInt2 == null) {
      arrayOfInt1 = null;
    }
    do
    {
      return arrayOfInt1;
      arrayOfInt1 = arrayOfInt2;
    } while (this.mBitmap == null);
    this.mBitmap.getPixels(arrayOfInt2, 0, this.mWidth, 0, 0, this.mWidth, this.mHeight);
    return arrayOfInt2;
  }
  
  public int getState()
  {
    return this.mState.get();
  }
  
  public int getWidth()
  {
    return this.mWidth;
  }
  
  public void lock()
  {
    this.mLock.lock();
  }
  
  public void releaseRef()
  {
    if (this.mRefCount.decrementAndGet() == 0)
    {
      if ((this.mBitmap != null) && (!this.mIsThumbnail)) {
        ARApp.getARApp().getBitmapPool().releaseBitmap(this.mBitmap);
      }
      this.mBitmap = null;
    }
  }
  
  public void setOverlayRequirement(int paramInt)
  {
    this.mOverlayRequirement = paramInt;
  }
  
  public void setPixels(int[] paramArrayOfInt)
  {
    if (paramArrayOfInt == null) {}
    while (this.mBitmap == null) {
      return;
    }
    this.mBitmap.setPixels(paramArrayOfInt, 0, this.mWidth, 0, 0, this.mWidth, this.mHeight);
  }
  
  public void setState(int paramInt)
  {
    if (this.mState.get() != 6) {
      this.mState.set(paramInt);
    }
  }
  
  public void unlock()
  {
    try
    {
      this.mLock.unlock();
      return;
    }
    catch (IllegalMonitorStateException localIllegalMonitorStateException) {}
  }
}
