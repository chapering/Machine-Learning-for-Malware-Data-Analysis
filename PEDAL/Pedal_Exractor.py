from pprint import pprint
import os
import sys
import fnmatch
import json
import mmap
import re
import numpy as np
from GlobalData import *
from pprint import pprint
import shutil
from PedalUtils import *

class PEDALApp(object):
    def __init__(self, RootSmali, SusiApiSrcMap, SusiApiSinkMap, PScoutWithIntentMap):

        # init based on inputs
        self.RootSmali = RootSmali
        self.SusiApiSrcMap = SusiApiSrcMap
        self.SusiApiSinkMap = SusiApiSinkMap
        self.PScoutWithIntentMap = PScoutWithIntentMap

        # Init code related acitivites
        self.Pkgs = self.GetJavaPkgs()
        self.ParPkgs = self.GetParPkgs()
        #self.PkgsShortNames = [p.split('smali'+os.path.sep)[1].strip() if os.path.basename(p) != 'smali' else 'smali' for p in self.Pkgs]
        #self.ParPkgsShortNames = [p.split('smali'+os.path.sep)[1].strip() if os.path.basename(p) != 'smali' else 'smali' for p in self.ParPkgs]
        self.PkgInfoDict = [{'ClassNames': [], 'MethodNames': [], 'FieldNames': [], 'Comps': [],
                             'APIs': set(), 'Perms': [], 'Srcs': set(), 'Sinks': set(), 'VI': set(),
                             'RTPerms': 'RTPermCheck_NO', 'ClassMethodFieldKW': set(),
                             'ClassMethodFieldStemmedKW': set(),
                             'InternetAccess':'InternetAccessCheck_No'} for P in self.Pkgs]

    def GetJavaPkgs(self):
        Pkgs = []
        for Root, Folders, Files in os.walk(self.RootSmali):
            for Folder in Folders:
                for F in os.listdir(os.path.join(Root, Folder)):
                    if F.endswith('smali'):
                        Pkgs.append(os.path.join(Root, Folder))
                        break
        Pkgs.sort()
        return Pkgs

    def GetParPkgs(self):
        ParPkgs = []
        for Pkg in self.Pkgs:
            ParPkg = os.path.dirname(Pkg)
            if not ParPkg in self.Pkgs:
                ParPkgs.append(Pkg)
        return ParPkgs

    def GenGetSmaliFilesFromPkg(self, Dir):
        '''
        Generator for yielding smali files one by one
        Dir: folder to get the smali files from
        Return: one smali file (at a time)
        '''
        for root, dirs, files in os.walk(Dir):
            for FileName in fnmatch.filter(files, '*.smali'):
                yield os.path.join(root, FileName)

    def GetVIIncludes(self, PkgName):
        '''
        Get all VI usage for a given package
        :param PkgName:
        :return: VI usage set
        '''
        VIClassImport = set()

        for SmaliFile in self.GenGetSmaliFilesFromPkg(PkgName):
            with open(SmaliFile, 'r') as FH:
                for Line in FH:
                    for Class in ImportedUIClasses:
                        if Class in Line:
                            VIClassImport.add('vi_' + Class)
        return VIClassImport

    def PopulateVIIncludes(self):
        '''
        Get VI usage for all pkgs within an app
        :return:
        '''
        for PId, PName in enumerate(self.Pkgs):
            self.PkgInfoDict[PId]['VI'] = self.GetVIIncludes(PName)
            print '+' * 10
            print PName, self.PkgInfoDict[PId]['VI']
            print '+' * 10

    def GetIdentifierNames(self, PkgIndex, IdentifierType):
        '''
        Get identifier names, i.e. class/method/field for a given package
        :param PkgIndex: Index of a package
        :param IdentifierType: 'class', 'method', 'field' or 'all'
        :return: Identifier names for the given type
        '''
        IdentifierType = IdentifierType.lower()
        if IdentifierType not in ['class', 'method', 'field', 'all']: return -1

        PkgName = self.Pkgs[PkgIndex]
        ClassNames = []
        MethodNames = []
        FieldNames = []
        for SmaliFile in self.GenGetSmaliFilesFromPkg(PkgName):
            with open(SmaliFile, 'r') as FH:
                for Line in FH:
                    if Line.startswith('.class'):
                        ClassName = Line.split(' ')[-1].strip()[:-1]
                        ClassName = os.path.basename(ClassName)  # getting the last part
                        ClassNames.append(ClassName)
                        continue
                    if Line.startswith('.method'):
                        MethodName = Line.split(' ')[-1].strip().split('(')[0].strip()
                        MethodNames.append(MethodName)
                        continue
                    if Line.startswith('.field'):
                        FieldName = Line.split(':')[0].split()[-1].strip().split(':')[0].strip()
                        FieldNames.append(FieldName)
                        continue
        if IdentifierType == 'all':
            return ClassNames, MethodNames, FieldNames
        elif IdentifierType == 'class':
            return ClassNames
        elif IdentifierType == 'method':
            return MethodNames
        else:
            return FieldNames

    def PopulateIdentifierNames(self):
        '''
        Get all identifier names for an app
        :return:
        '''
        for PId, PName in enumerate(self.Pkgs):
            CNames, MNames, FNames = self.GetIdentifierNames(PId, 'all')
            self.PkgInfoDict[PId]['ClassNames'] = CNames
            self.PkgInfoDict[PId]['MethodNames'] = MNames
            self.PkgInfoDict[PId]['FieldNames'] = FNames
            print '+' * 10
            print PName
            print len(CNames)
            print len(MNames)
            print len(FNames)
            print '+' * 10

    def PopulateKeyWordsFromIdentifiers(self):
        '''
        Get set of identifiers that contains key words
        :return:
        '''
        FoundKWs = set()
        FoundStemmedKWs = set()
        for PId, PkgName in enumerate(self.Pkgs):
            CNames = set([X.lower() for X in self.PkgInfoDict[PId]['ClassNames']])
            MNames = set([X.lower() for X in self.PkgInfoDict[PId]['MethodNames']])
            FNames = set([X.lower() for X in self.PkgInfoDict[PId]['FieldNames']])
            for KW in Keywords:
                for C in CNames:
                    if KW in C:
                        FoundKWs.add('KW_Class_' + KW)
                        break
                for M in MNames:
                    if KW in M:
                        FoundKWs.add('KW_Method_' + KW)
                        break
                for F in FNames:
                    if KW in F:
                        FoundKWs.add('KW_Field_' + KW)
                        break
            for KW in StemmedKeywords:
                for C in CNames:
                    if KW in C:
                        FoundStemmedKWs.add('StemmedKW_Class_' + KW)
                        break
                for M in MNames:
                    if KW in M:
                        FoundStemmedKWs.add('StemmedKW_Method_' + KW)
                        break
                for F in FNames:
                    if KW in F:
                        FoundStemmedKWs.add('StemmedKW_Field_' + KW)
                        break
            self.PkgInfoDict[PId]['ClassMethodFieldKW'] = FoundKWs
            self.PkgInfoDict[PId]['ClassMethodFieldStemmedKW'] = FoundStemmedKWs

            # may remove other class, method and field key,val pairs from dict
            self.PkgInfoDict[PId].pop('ClassNames')
            self.PkgInfoDict[PId].pop('MethodNames')
            self.PkgInfoDict[PId].pop('FieldNames')
            self.PkgInfoDict[PId].pop('APIs')

    def GetCompUsages(self, PkgIndex):
        '''
        Get component usage for a given package
        :param PkgIndex: Index of a package
        :return:
        '''
        PkgName = self.Pkgs[PkgIndex]
        CompsUsage = set()
        for Api in self.PkgInfoDict[PkgIndex]['APIs']:
            if 'Activity' in Api: CompsUsage.add('comp_activity_used')
            if 'Service' in Api: CompsUsage.add('comp_service_used')
            if 'Content' in Api: CompsUsage.add('comp_contentprovider_used')
            if 'Broadcast' in Api: CompsUsage.add('comp_broadcastreceiver_used')
        return CompsUsage

    def PopulateCompUsages(self):
        '''
        Get component usage for all packages within an app
        :return:
        '''
        for PId, PName in enumerate(self.Pkgs):
            CompsUsage = self.GetCompUsages(PId)
            self.PkgInfoDict[PId]['Comps'] = CompsUsage
            print '+' * 10
            print PName, CompsUsage
            print '+' * 10

    def GetRTPermsUsage(self, PId):
        '''
        Get runtime permission usage for a given package
        :param PId: Index of a package
        :return:
        '''
        for Api in self.PkgInfoDict[PId]['APIs']:
            ApiName = Api.split()[1]
            if ApiName in RTPermCheckAPIs:
                return 1
        return 0

    def PopulateRTPermsUsage(self):
        '''
        Get runtime permission usage for all packages within an app
        :return:
        '''
        for PId, PName in enumerate(self.Pkgs):
            RTPermsUsage = self.GetRTPermsUsage(PId)
            if RTPermsUsage:
                self.PkgInfoDict[PId]['RTPerms'] = 'RTPermCheck_YES'
            print '+' * 10
            print PName, RTPermsUsage
            print '+' * 10

    def GetAPIsUsed(self, PkgIndex):
        '''
        Get API usage for a given package
        :param PkgIndex: Index of a package
        :return:
        '''
        PkgName = self.Pkgs[PkgIndex]
        APIsUsed = set()

        for SmaliFile in self.GenGetSmaliFilesFromPkg(PkgName):
            with open(SmaliFile, 'r') as FH:
                for Line in FH:
                    Line = Line.strip()
                    if Line.startswith("invoke-"):
                        Parts = Line.split(",")
                        for Part in Parts:
                            if ";->" in Part:
                                Part = Part.strip()
                                for APIPrefix in AndroidAPIs:
                                    if Part.startswith(APIPrefix):
                                        ApiParts = Part.split(";->")
                                        ApiClass = ApiParts[0].strip()
                                        ApiName = ApiParts[1].split("(")[0].strip()
                                        APIsUsed.add(ApiClass + ' ' + ApiName)
        return APIsUsed

    def PopulateAPIPermSrcSinkUsages(self):
        '''
        Get API (Susi category level) usage for all packages within an app
        :return:
        '''
        for PId, PName in enumerate(self.Pkgs):
            APIsUsed = self.GetAPIsUsed(PId)
            self.PkgInfoDict[PId]['APIs'] = APIsUsed
            Srcs = GetSusiSrcsSinks(APIsUsed, self.SusiApiSrcMap)
            Sinks = GetSusiSrcsSinks(APIsUsed, self.SusiApiSinkMap)
            Perms = GetPermsUsed(APIsUsed, self.PScoutWithIntentMap)
            self.PkgInfoDict[PId]['Srcs'] = ['SRC_' + S.replace('(', '').replace(')', '') for S in Srcs]
            self.PkgInfoDict[PId]['Sinks'] = ['SINK_' + S.replace('(', '').replace(')', '') for S in Sinks]
            self.PkgInfoDict[PId]['Perms'] = Perms
            print '+' * 10
            print PName, Srcs, Sinks, Perms
            print '+' * 10

    def GetInternetAccess(self, PId):
        '''
        Get whether a package accessing Internet
        :param PId: Index of a package
        :return:
        '''
        InternetPerms = ['android.permission.internet',
                         'android.permission.access_network_state',
                         'android.permission.access_wifi_state']
        InternetPerms = set(InternetPerms)
        if InternetPerms & set(self.PkgInfoDict[PId]['Perms']):
            return 1
        return 0

    def PopulateInternetAccess(self):
        '''
        Get Internet access for all packages within an app
        :return:
        '''
        for PId, PName in enumerate(self.Pkgs):
            InternetAccess= self.GetInternetAccess(PId)
            if InternetAccess:
                self.PkgInfoDict[PId]['InternetAccess'] = 'InternetAccessCheck_Yes'
            print '+' * 10
            print PName, InternetAccess
            print '+' * 10

    def DumpToFile(self, OPFName):
        '''
        Dumping all features into feature files
        :param OPFName:
        :return:
        '''
        createdir('Features')
        for PId, PkgInfo in enumerate(self.PkgInfoDict):
            if os.path.basename(self.Pkgs[PId]) != 'smali':
                DumpFName = 'Features' + os.sep + OPFName + "_" + self.Pkgs[PId].split('smali')[1].strip().replace(os.path.sep, '.')[1:]
            else:
                DumpFName = 'Features' + os.sep + OPFName + '_smali'

            with open(DumpFName + '.Features', 'w') as FH:
                for K, V in PkgInfo.iteritems():
                    if hasattr(V, '__iter__'):
                        # value V is an iterable
                        for Elem in V:
                            print >> FH, Elem
                    else:
                        # value V is not an iterable
                        print >> FH, V

def GetPermsUsed(APIsUsed, PScoutWithIntentMap):
    '''
    Get permission usage based on PScout mapping
    :param APIsUsed: API usage of an app
    :param PScoutWithIntentMap:
    :return:
    '''
    PermsUsed = set()
    for Api in APIsUsed:
        if Api.startswith('L'):
            Api = Api[1:]
        Api = Api.replace('/', '.').lower()

        Perms = PScoutWithIntentMap.get(Api, None)
        if not Perms: continue
        for P in Perms:
            PermsUsed.add(P)
    # may use PermsUsed in my ALD later
    PEDALPermsUsed = [P for P in PermsUsed if P in PermsCheckedByPEDAL]
    return PEDALPermsUsed


def GetSusiSrcsSinks(ApiList, SusiMap):
    '''
    Get sources and sinks used in a list of android APIs
    :param List ApiList
    :param Susi.SusiDictMaker SusiMap
    :return SourceSet: Set of SUSI src
    :rtype Set<String>
    :return SinkSet: Set of SUSI sink
    :rtype Set<String>
    '''

    SourceSinkSet = set()
    for Api in ApiList:
        if Api.startswith('L'):
            Api = Api[1:]
        Api = Api.replace('/', '.')
        # Api can be used as key. Api contains class name <space> api name
        SrcSink = SusiMap.get(Api, None)
        if SrcSink:
            SourceSinkSet.add(SrcSink)
    return SourceSinkSet


def main(AppDir):
    '''
    Extract features files for given apps
    :param AppDir: Directory of apps to be extracted
    :return:
    '''
    with open('SusiAPISrcDict.json', 'r') as f:
        SusiApiSrcMap = json.load(f)
    with open('SusiAPISinkDict.json', 'r') as f:
        SusiApiSinkMap = json.load(f)
    with open('PScoutApiPermMappingWithINTENTs.json', 'r') as f:
        PScoutWithIntentMap = json.load(f)



    for root, dirs, files in os.walk(AppDir):
        for file in files:
            if file.endswith('.apk'):
                ApktoolCommand = "java -jar apktool.jar d -f " + os.path.join(root, file) 
                os.system(ApktoolCommand)
                RootSmali = file.split('.apk')[0]+os.sep
                print 'Processing ' + file
                App = PEDALApp(RootSmali, SusiApiSrcMap, SusiApiSinkMap, PScoutWithIntentMap)
                OPPrefix = os.path.basename(file).split('.apk')[0]

                App.PopulateAPIPermSrcSinkUsages()
                App.PopulateVIIncludes()
                App.PopulateRTPermsUsage()
                App.PopulateCompUsages()
                App.PopulateIdentifierNames()
                App.PopulateKeyWordsFromIdentifiers()
                App.PopulateInternetAccess()
                App.DumpToFile(OPPrefix)

                print 'Deleting decompilation files '+RootSmali+' ...'
                shutil.rmtree(RootSmali)
                print 'Deletion Finished'

if __name__ == "__main__":
    AppDir = sys.argv[1]
    print AppDir
    main(AppDir)

    print 'done'
